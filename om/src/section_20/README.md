# The pillars of the OOP

- abstraction
- encapsulation
- inheritance
- polymorphism

# Classes

- Every attribute is public by default

- Then, the <code>public</code> access modifier is redundant

- Every method is public by default

- The first **readonly** makes the attribute immutable

- The second **readonly** makes an array immutable

- private readonly contributors: **readonly** Contributor[] = []

- Everytime we create a class we are creating a type

# Reviewing tsconifig

- <a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html" title="Documentation">tsconfig</a>

- <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" title="Documentation">Optional chaining</a>

- <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing">Nullish coalescing operator</a>

- <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll">replaceAll</a>

- <a href="https://kangax.github.io/compat-table/es2016plus/#node12_11">ECMAScript compatibilities</a>

- The <code>target</code> key reffers to the EcmaScript version

- The <code>allowJs</code> key allows import js file inside ts file. It is useful when we are migrating a project

- The <code>outDir</code> key specifies the bundled file outDir generated by the ts (not by the webpack in frontend). It is not useful when dealing with frontend.

- To bundle frontend, we should use webpack

- <code>rootDir</code> specifies the entry folder. Some developers define only the rootDir folder and does not defines the <code>include</code> property. It works

- <code>noEmit</code> says that we dont wanna compile our ts files. Instead, we wanna just check

- <code>noEmitOnError</code> doesn't allow compilation if there is any error

- <code>strict</code> as true enable all strict options in ts

- We must set strict to false an dealing with each strict option when migrating a js base to a ts one

- We have decorator options too (since ES7). They are experimental

- We use <code>"module": "commonjs</code> when compiling to a backend

# Access modifiers: public and private

- We are talking about access a property (attribute or method) of a class

- <code>public</code> allows access a property in the class, outside the class an in the subclasses

- <code>private</code> allow access a property only inside a class

- We generally use public methods to access/manipulate private properties

- <code>public</code> is redundant in first constructor: it is the default for all attributes and methods

- <code>public</code> is necessary in second constructor

```typescript
// both constructors acts the same way

class Enterprise {
	public name: string
	constructor (name: string) {
		this.name = name		
	}
}

class Enterprise {
	constructor( public name: string) {
		this.name = name
	}
}
```

# Inheritance in Typescript

- access modifiers:

```
+ public
- private
# protected (not accessible outside the class or the subclass)
```

- We use <code>extends</code> to inherit from a class

- We can inherit from both a concrete or abstract class

- We can override methods in the subclasses

- It is better to use composition instead of inheritance

- **TypeScript doesn't allow inherit from more than one class**

- **TypeScript allows a class implements more than one interface**

# Super: to access the super class

- <code>super</code> allows access the *super* class from the *subclass*

- <code>super.property></code> to access *super* property (attribute or method)

- TS raises warnings when defining constructors in the subclasses

- But, we can override constructor in the subclass, (eg: adding more arguments)

- And then we can call the super contructor in subclass constructor

# Protected

- <code>protected</code> allows access a property in a class and in subclasses

# Getters and Setters

- We expose private properties through public methods

- We prefix this public methods with <code>get</code> or <code>set</code>

- Then, we call this public methods as *getter and setters*

- This is the old way to create getters and setters

```typescript
export class Person {
	constructor(
		private name: string,
		private lastName: string,
		private age: number,
		private cpf: string
	) {}

	setCpf(value: string): void {
		this.cpf = value
	}

	getCpf(): string {
		return this.cpf.replace(/\D/g, '')
	}
}
```

- New way to this in typescript

```typescript
export class Person {
	constructor(
		private name: string,
		private lastName: string,
		private age: number,
		private _cpf: string
	) {
		console.log('this.cpf and _cpf', this.cpf, _cpf)
		this.cpf = _cpf
	}

	// It acts like a class attribute (it is not a method)
	// It its the reason why we use _cpf instead of cpf
	// We cannot specify a return type in a set
	set cpf(value: string) {
		console.log('Setting cpf')
		this._cpf = value
	}

	get cpf(): string {
		console.log('Getting cpf')
		return this._cpf.replace(/\D/g, '')
	}
}

const person = new Person('Bruno', 'Conde', 14, '000-000-000-00')

console.log(person.cpf)

person.cpf = '111-111-111-11'
console.log(person.cpf)
```

# static properties

- Are accessible through the class

- They are doesn't need to instantiate the class

- They are not accessible through the object

- It behave (bu not is) a method inside the class

- We cannot access static properties inside the class using this

- We can only access a static property, even inside the class, through the class

# Private constructor and sigleton pattern

- Singleton aim to has only one instance of a class in the whole system

- We can achieve this using a private constructor

```typescript
// Singleton | Factory method

export class Database {
	private static database: Database

	private constructor(
		private host: string,
		private user: string,
		private password: string
	) {}

	connect(): void {
		console.log(`Connected to: ${this.host} ${this.user} ${this.password}`)
	}

	// It is a factory method
	static getDatabase(
		host: string,
		user: string,
		password: string
	): Database {
		if (Database.database) {
			console.log('Returning existing instance')
			return Database.database
		}

		console.log('Creating new instance')
		Database.database = new Database(host, user, password)
		return Database.database
	}
}

const db1 = Database.getDatabase('localhost', 'root', '123456')
const db2 = Database.getDatabase('localhost', 'root', '123456')

db1.connect()
db2.connect()

console.log(db1 === db2) // true
```

# Abstract properties

- It forces subclasses override methods or attributes

- We use protected to allow access properties in subclasses

- We can have both concrete and abstract properties in a abstract class

- Abstract classes cannot be instantiated

- It can only be inherited

- A abstract method cannot have body

- <code>\uxxxx</code> is a unicode

- <code>\u{xxxxx}</code> is a unicode greather then 4 characters

- The abstract class cannot be instantiated but it create a type

- All properties of a abstract class are passed to to the concrete class

```typescript
export abstract class Character {
	protected abstract emoji: string

	constructor(
		protected name: string,
		protected attack: number,
		protected life: number
	) {}

	attackEnemy(character: Character): void {
		this.catchPhrase()		
		character.loseLife(this.attack)
	}

	loseLife(attack: number): void {
		this.life -= attack
		console.log(`${this.emoji} - ${this.name}'s life: ${this.life}`)
	}

	abstract catchPhrase(): void
}

class Warrior extends Character {
	protected emoji = '\u{1F9DD}'
	catchPhrase(): void {
		console.log(this.emoji + " Warrior's attack")
	}
}
class Monster extends Character {
	protected emoji = '\u{1F9DF}'
	catchPhrase(): void {
		console.log(this.emoji + " Monster's attack")
	}
}

const warrior = new Warrior('Bruno', 100, 1000)
const monster = new Monster('Heliar', 87, 1000)

warrior.attackEnemy(monster)
warrior.attackEnemy(monster)

monster.attackEnemy(warrior)
monster.attackEnemy(warrior)
```

# Association between classes

- It is a week relationship between objects

- Use association term when a class uses another

```typescript
export class Writer {
	private _tool: Tool | null = null

	constructor(private _name: string) {}

	get name(): string {
		return this._name
	}

	set tool(tool: Tool | null) {
		this._tool = tool
	}

	get tool(): Tool | null {
		return this._tool
	}

	write(): void {
		if (this.tool === null) {
			console.log('I cannot write without a tool')
			return
		}
		this.tool.write()
	}
}

export abstract class Tool {
	constructor(private _name: string) {}

	abstract write(): void

	get name(): string {
		return this._name
	}
}

export class Pen extends Tool {
	write(): void {
		console.log(`${this.name} is writing`)
	}
}

export class TypeWriter extends Tool {
	write(): void {
		console.log(`${this.name} is typing`)
	}
}

const writer = new Writer('Bruno')
const pen = new Pen('Bic')
const typeWriter = new TypeWriter('IBM')

writer.write()

writer.tool = pen
writer.write()

writer.tool = typeWriter
writer.write()
```

- Note that the writer depends on a Tool

- Note that a Tool is a abstract class

- Then, the writer depends on an abstraction instead of a concrete class

# Agregation

- An object contains another

- A class depends on another

- But, the objects can live separately

- **Here, whe inject the object instantiated ouside the class**

```typescript
export class ShoppingCart {
	private readonly products: Product[] = []

	// rest operator allows receice one product or an array
	addProduct(...products: Product[]): void {
		for (const product of products) {
			this.products.push(product)
		}
	}

	amountOfProducts(): number {
		return this.products.length
	}

	totalPrice(): number {
		return this.products.reduce(
			(accum, current) => accum + current.price, 0
		)
	}
}

export class Product {
	constructor(
		public name: string,
		public price: number
	) {}

}

const tShirt = new Product('t-shirt', 48)
const pen = new Product('pen', 2.50)
const backpack = new Product('backpack', 50)

const shoppingCart = new ShoppingCart()
shoppingCart.addProduct(tShirt, pen, backpack)
console.log(shoppingCart.totalPrice())
```

# Composition

- An object contains another

- An object depends on another

- An objects cannot live without another

- It is a strong composition

- **Here, we instantiate objects inside the class**

```typescript
export class Car {
	private readonly motor: Motor = new Motor()

	turnOn(): void {
		this.motor.turnOn()
	}

	accelerate(): void {
		this.motor.accelerate()
	}

	stop(): void {
		this.motor.stop()
	}

	turnOff(): void {
		this.motor.turnOff()
	}
}

export class Motor {
	turnOn(): void {
		console.log('Motor in on')
	}

	accelerate(): void {
		console.log('Motor is accelerate')
	}

	stop(): void {
		console.log('Motor stopped')
	}

	turnOff(): void {
		console.log('Motor is off')
	}
}

const car = new Car()

car.turnOn()
car.accelerate()
car.stop()
car.turnOff()
```

# Type alias in classes

- We can change the access modifier of properties in the concrete class

- But this change cannot be more restrictive than the mother class

- We need call the constructor of the mother class in the subclass
- Even if the constuctor is absent in the mother class

- We use <code>implements</code> to implement a type alias

- We have no access modifiers in the type alias

- All properties declared in a type are public

- Then, if we need access modifiers, we need a interface or an abstract class

- A type alias acts like an interface

- Because it forces the class implement things specified in type

- Like interfaces, we can implement more than one type at once

```typescript
type Name = {
	name: string
}

type LastName = {
	lastName: string
}

type FullName = {
	fullName: () => string
}

export class Person implements Name, LastName, FullName {
	constructor(
		public name: string,
		public lastName: string
	) {}

	// we can change the access modifier in the concrete property
	fullName(): string {
		return `${this.name} ${this.lastName}`
	}
}

const person = new Person('Bruno', 'Conde')

console.log(person.fullName())
```

# Interfaces

- It seams type alias in 99 % of cases

- But we use interfaces when modelling objects

- A interface can extend more than an interface at once

```typescript
interface Name {
	name: string
}

interface LastName {
	lastName: string
}

interface FullName {
	fullName: () => string
}

interface PersonType extends Name, LastName, FullName {}

export class Person implements PersonType {
	constructor(
		public name: string,
		public lastName: string
	) {}

	// we can change the access modifier in the concrete property
	fullName(): string {
		return `${this.name} ${this.lastName}`
	}
}

const person = new Person('Bruno', 'Conde')

console.log(person.fullName())

// remember structural typing in typescript

const person2: PersonType = {
	name: 'Bruno',
	lastName: 'Conde',
	fullName() {
		return `${this.name} ${this.lastName}`
	}
}

console.log(person2.fullName())
```

# Using interfaces and classes

- <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video">Tag video</a>

- Copy html and css from course folder

- Edit sectio_19/19_exercise/exercise.ts to this

```typescript
// import './form-control'
import '../../section_20/15_using_interfaces_and_classes/using-interfaces-and-classes'
```

- Build frontend

```bash
npm run build:frontend
```

- Open live server (/frontend/video.html)

# Declaration merge in interfaces

- Interfaces and type alias are almost the same

- But, there is some differences

- On major difference is declaration merge

- **Declaration merge** tells the things bellow

- We cannot have interfaces and type alias with the same name

- But, we can have interfaces with the same name

- The final result is the merge between the interfaces with the same name

```typescript
export interface Person {
	name: string
}

export interface Person {
	readonly lastName: string
}

export interface Person {
	// reaonly
	// 1ยบ -> applyed to the property reference
	// 2ยบ -> applyed to the value
	readonly addresses: readonly string[]
}

export interface Person {
	// The property can be number | undefined
	// Because it is optional
	readonly age?: number
}

const person: Person = {
	name: 'Bruno',
	lastName: 'Conde',
	addresses: ['123 Central Avenue']
}

console.log(person)
```